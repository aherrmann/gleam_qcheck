//// This module provides functions for running property-based tests.
//// 
//// ## Example
//// 
//// Here is a basic example to get you started.  It assumes you are using 
//// gleeunit to run the tests.
//// 
//// ```gleam
//// import qcheck/generator
//// import qcheck/qtest
////
//// pub fn small_positive_or_zero_int__test() {
////   use n <- qtest.given(generator.small_positive_or_zero_int())
////   n + 1 == 1 + n
//// }
//// 
//// pub fn small_positive_or_zero_int__failures_shrink_to_zero__test() {
////   use n <- qtest.given(generator.small_positive_or_zero_int())
////   n + 1 != 1 + n
//// }
//// ```
//// 
//// The first test will pass, but the second will fail with an error that may
//// look something like this if you are using the Erlang target:
//// 
//// ```
////  Failures:
//// 
////    1) qcheck/gen_int_test.small_positive_or_zero_int__failures_shrink_to_zero__test
////       Failure: <<"TestError[original_value: 10; shrunk_value: 0; shrink_steps: 1;]">>
////       stacktrace:
////         qcheck_ffi.fail
////       output: 
//// ```
//// 
//// 

import gleam/string
import qcheck/generator.{type Generator, Generator}
import qcheck/qtest/config.{type Config} as qtest_config
import qcheck/qtest/test_error
import qcheck/shrink
import qcheck/tree.{type Tree, Tree}
import qcheck/try.{NoPanic, Panic, try}

/// `run(config, generator, property)` runs the `property` function against some
/// test cases generated by the `generator` function according to the specified 
/// `config`
/// 
/// The `run` function returns `Nil` if the property holds (i.e., return 
/// `True` for all test cases), or panics if the property does not 
/// hold for some test case `a` (i.e., returns `False` or `panic`s).
/// 
/// 
pub fn run(
  config config: Config,
  generator generator: Generator(a),
  property property: fn(a) -> Bool,
) -> Nil {
  do_run(config, generator, property, 0)
}

/// A specialized version of `run` that uses the default configuration.
/// 
/// 
pub fn given(
  generator generator: Generator(a),
  property property: fn(a) -> Bool,
) -> Nil {
  run(qtest_config.default(), generator, property)
}

/// `run_result(config, generator, property)` is like `run` but the property
/// function returns a `Result` instead of a `Bool`.
/// 
///
pub fn run_result(
  config config: Config,
  generator generator: Generator(a),
  property property: fn(a) -> Result(b, error),
) -> Nil {
  do_run_result(config, generator, property, 0)
}

/// A specialized version of `run_result` that uses the default configuration.
/// 
/// 
pub fn given_result(
  generator generator: Generator(a),
  property property: fn(a) -> Result(b, error),
) -> Nil {
  run_result(qtest_config.default(), generator, property)
}

fn do_run(
  config: Config,
  generator: Generator(a),
  property: fn(a) -> Bool,
  i: Int,
) -> Nil {
  case i >= config.test_count {
    True -> Nil
    False -> {
      let Generator(generate) = generator
      let #(tree, seed) = generate(config.random_seed)
      let Tree(value, _shrinks) = tree

      case try.try(fn() { property(value) }) {
        NoPanic(True) ->
          do_run(
            config
              |> qtest_config.with_random_seed(seed),
            generator,
            property,
            i + 1,
          )
        NoPanic(False) -> {
          let #(shrunk_value, shrink_steps) =
            shrink.shrink(
              tree,
              property,
              run_property_max_retries: config.max_retries,
            )

          test_error.failwith(
            original_value: value,
            shrunk_value: shrunk_value,
            shrink_steps: shrink_steps,
            error_msg: "property was False",
          )
        }
        Panic(exn) -> {
          let #(shrunk_value, shrink_steps) =
            shrink.shrink(
              tree,
              property,
              run_property_max_retries: config.max_retries,
            )

          test_error.failwith(
            original_value: value,
            shrunk_value: shrunk_value,
            shrink_steps: shrink_steps,
            error_msg: string.inspect(exn),
          )
        }
      }
    }
  }
}

fn do_run_result(
  config: Config,
  generator: Generator(a),
  property: fn(a) -> Result(b, error),
  i: Int,
) -> Nil {
  case i >= config.test_count {
    True -> Nil
    False -> {
      let Generator(generate) = generator
      let #(tree, seed) = generate(config.random_seed)
      let Tree(value, _shrinks) = tree

      case try(fn() { property(value) }) {
        NoPanic(Ok(_)) ->
          do_run_result(
            config
              |> qtest_config.with_random_seed(seed),
            generator,
            property,
            i + 1,
          )
        NoPanic(Error(e)) -> {
          let #(shrunk_value, shrink_steps) =
            shrink.shrink_result(
              tree,
              property,
              run_property_max_retries: config.max_retries,
            )

          test_error.failwith(
            original_value: value,
            shrunk_value: shrunk_value,
            shrink_steps: shrink_steps,
            error_msg: string.inspect(e),
          )
        }
        Panic(exn) -> {
          let #(shrunk_value, shrink_steps) =
            shrink.shrink_result(
              tree,
              property,
              run_property_max_retries: config.max_retries,
            )

          test_error.failwith(
            original_value: value,
            shrunk_value: shrunk_value,
            shrink_steps: shrink_steps,
            error_msg: string.inspect(exn),
          )
        }
      }
    }
  }
}
