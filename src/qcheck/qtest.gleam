//// This module provides functions for running property-based tests.
//// 
//// ## Example
//// 
//// Here is a basic example to get you started.  It assumes you are using 
//// gleeunit to run the tests.
//// 
//// ```gleam
//// import gleeunit/should
//// import qcheck/generator
//// import qcheck/qtest
//// import qcheck/qtest/config as qtest_config
////
//// pub fn small_positive_or_zero_int__test() {
////   qtest.run(
////     config: qtest_config.default(),
////     generator: generator.small_positive_or_zero_int(),
////     property: fn(n) { n + 1 == 1 + n },
////   )
////   |> should.equal(Ok(Nil))
//// }
//// 
//// pub fn small_positive_or_zero_int__failures_shrink_to_zero__test() {
////   qtest.run(
////     config: qtest_config.default(),
////     generator: generator.small_positive_or_zero_int(),
////     property: fn(n) { n + 1 != 1 + n },
////   )
////   |> should.equal(Error(0))
//// }
//// ```

import exception
import qcheck/generator.{type Generator, Generator}
import qcheck/qtest/config.{type Config} as qtest_config
import qcheck/qtest/test_error
import qcheck/shrink
import qcheck/tree.{type Tree, Tree}

fn do_run(
  config: Config,
  generator: Generator(a),
  property: fn(a) -> Bool,
  i: Int,
) -> Result(Nil, a) {
  case i >= config.test_count {
    True -> Ok(Nil)
    False -> {
      let Generator(generate) = generator
      let #(tree, seed) = generate(config.random_seed)
      let Tree(value, _shrinks) = tree

      case property(value) {
        True ->
          do_run(
            config
              |> qtest_config.with_random_seed(seed),
            generator,
            property,
            i + 1,
          )
        False -> {
          let shrunk_value =
            shrink.shrink(
              tree,
              property,
              run_property_max_retries: config.max_retries,
            )
          Error(shrunk_value)
        }
      }
    }
  }
}

/// `run(config, generator, property)` runs the `property` function against some
/// test cases generated by the `generator` function according to the specified 
/// `config`
/// 
/// The `run` function returns `Ok(Nil)` if the property holds (i.e., return 
/// `True` for all test cases), and returns `Error(a)` if the property does not 
/// hold for some test case `a`.  The value returned in the Error case will be a
/// shrunk value if possible.
pub fn run(
  config config: Config,
  generator generator: Generator(a),
  property property: fn(a) -> Bool,
) -> Result(Nil, a) {
  do_run(config, generator, property, 0)
}

fn do_run_result(
  config: Config,
  generator: Generator(a),
  property: fn(a) -> Result(b, error),
  i: Int,
) -> Result(Nil, a) {
  case i >= config.test_count {
    True -> Ok(Nil)
    False -> {
      let Generator(generate) = generator
      let #(tree, seed) = generate(config.random_seed)
      let Tree(value, _shrinks) = tree

      case property(value) {
        Ok(_) ->
          do_run_result(
            config
              |> qtest_config.with_random_seed(seed),
            generator,
            property,
            i + 1,
          )
        Error(_) -> {
          let shrunk_value =
            shrink.shrink_result(
              tree,
              property,
              run_property_max_retries: config.max_retries,
            )
          Error(shrunk_value)
        }
      }
    }
  }
}

/// `run_result(config, generator, property)` is like `run` but the property
/// function returns a `Result` instead of a `Bool`.
/// 
/// The `run_result` function returns `Ok(Nil)` if the property holds (i.e.,
/// returns `Ok` for all test cases), and returns `Error(a)` if the property 
/// does not hold for some test case `a`. The value returned in the Error case 
/// will be a shrunk value if possible.
pub fn run_result(
  config config: Config,
  generator generator: Generator(a),
  property property: fn(a) -> Result(b, error),
) -> Result(Nil, a) {
  do_run_result(config, generator, property, 0)
}

pub fn run_assert(
  config config: Config,
  generator generator: Generator(a),
  property property: fn(a) -> b,
) -> Nil {
  do_run_assert(config, generator, property, 0)
}

fn do_run_assert(
  config: Config,
  generator: Generator(a),
  property: fn(a) -> b,
  i: Int,
) -> Nil {
  case i >= config.test_count {
    True -> Nil
    False -> {
      let Generator(generate) = generator
      let #(tree, seed) = generate(config.random_seed)
      let Tree(value, _shrinks) = tree

      let result = exception.rescue(fn() { property(value) })

      case result {
        Ok(_) -> {
          do_run_assert(
            config
              |> qtest_config.with_random_seed(seed),
            generator,
            property,
            i + 1,
          )
        }
        Error(_) -> {
          let #(shrunk_value, shrink_steps) =
            shrink.shrink_panic(
              tree,
              property,
              run_property_max_retries: config.max_retries,
            )

          test_error.failwith(
            original_value: value,
            shrunk_value: shrunk_value,
            shrink_steps: shrink_steps,
          )
        }
      }
    }
  }
}
